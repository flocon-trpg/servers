/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin=(()=>{var me=Object.create,O=Object.defineProperty;var ge=Object.getOwnPropertyDescriptor;var he=Object.getOwnPropertyNames,q=Object.getOwnPropertySymbols,Pe=Object.getPrototypeOf,Z=Object.prototype.hasOwnProperty,ye=Object.prototype.propertyIsEnumerable;var G=(e,t,n)=>t in e?O(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,F=(e,t)=>{for(var n in t||(t={}))Z.call(t,n)&&G(e,n,t[n]);if(q)for(var n of q(t))ye.call(t,n)&&G(e,n,t[n]);return e};var ke=e=>O(e,"__esModule",{value:!0});var p=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var B=(e,t)=>{for(var n in t)O(e,n,{get:t[n],enumerable:!0})},we=(e,t,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of he(t))!Z.call(e,i)&&i!=="default"&&O(e,i,{get:()=>t[i],enumerable:!(n=ge(t,i))||n.enumerable});return e},u=e=>we(ke(O(e!=null?me(Pe(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var Oe={};B(Oe,{default:()=>Me});var le=u(p("@yarnpkg/cli")),I=u(p("@yarnpkg/core")),k=u(p("clipanion"));var a=u(p("@yarnpkg/core")),g=u(p("@yarnpkg/fslib"));var z={};B(z,{fs:()=>Te,getPackagePath:()=>xe});var Q=u(p("@yarnpkg/plugin-pnp")),Y=u(p("@yarnpkg/core")),R=u(p("@yarnpkg/fslib")),X=u(p("@yarnpkg/libzip")),xe=async(e,t)=>{ve(e);let n=Y.structUtils.convertPackageToLocator(t),i={name:Y.structUtils.stringifyIdent(n),reference:n.reference},o=_.getPackageInformation(i);if(!o)return null;let{packageLocation:r}=o;return r},_,ve=e=>{_||(_=module.require((0,Q.getPnpPath)(e).cjs))},Te=new R.VirtualFS({baseFs:new R.ZipOpenFS({libzip:(0,X.getLibzipSync)(),readOnlyArchives:!0})});var V={};B(V,{_getYarnStateAliases:()=>ne,fs:()=>Le,getPackagePath:()=>Ne});var L=u(p("@yarnpkg/core")),ee=u(p("@yarnpkg/parsers")),T=u(p("@yarnpkg/fslib")),Ne=async(e,t)=>{await be(e);let n=L.structUtils.convertPackageToLocator(t),i=L.structUtils.stringifyLocator(n),o=C[i]||te[i];if(!o)return null;let r=o.locations[0];return r?T.ppath.join(e.cwd,r):e.cwd},C,te,be=async e=>{if(!C){let t=T.ppath.join(e.configuration.projectCwd,T.Filename.nodeModules,".yarn-state.yml");C=(0,ee.parseSyml)(await T.xfs.readFilePromise(t,"utf8")),te=ne(C)}},Le=T.xfs,ne=e=>Object.entries(e).reduce((t,[n,i])=>{if(!i.aliases)return t;let o=L.structUtils.parseLocator(n);for(let r of i.aliases){let s=L.structUtils.makeLocator(o,r),f=L.structUtils.stringifyLocator(s);t[f]=i}return t},{});var K=e=>{switch(e){case"pnp":return z;case"node-modules":return V;default:throw new Error("Unsupported linker")}};var ie="*",Je=g.npath.basename(__dirname)==="@yarnpkg"?g.ppath.join(g.npath.toPortablePath(__dirname),"../.."):g.ppath.join(g.npath.toPortablePath(__dirname),".."),$=(e,t)=>e.fs.readFilePromise(t,"utf8").catch(n=>{if(n.message.includes("no such file or directory"))return null;throw n}),re=async(e,t,n,i,o,r)=>{let s={},f={children:s},w=await oe(e,n,i,o),m=K(e.configuration.get("nodeLinker"));for(let[c,l]of w.entries()){let d=await m.getPackagePath(e,l);if(d===null)continue;let x=g.ppath.join(d,g.Filename.manifest),h=await $(m,x);if(h===null)continue;let D=JSON.parse(h),{license:v,url:E,vendorName:b,vendorUrl:S}=Ee(D);s[v]||(s[v]={value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,v),children:{}});let M=a.structUtils.convertPackageToLocator(l),P=a.formatUtils.tuple(a.formatUtils.Type.DEPENDENT,{locator:M,descriptor:c}),y=r?{}:F(F(F({},E?{url:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,J("URL",E,t))}}:{}),b?{vendorName:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,J("VendorName",b,t))}}:{}),S?{vendorUrl:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,J("VendorUrl",S,t))}}:{}),pe={value:P,children:y},ue=a.structUtils.stringifyLocator(M),fe=s[v].children;fe[ue]=pe}return f},se=(e,t)=>{for(let n of t)[...e].filter(([,i])=>i.scope!==n.scope?!1:n.name===ie?!0:i.name===n.name).forEach(([i])=>{e.delete(i)})},oe=async(e,t,n,i)=>{var m;let o=new Map,r,s=new Set(["api-server","cache"]);if(t){if(n){for(let l of e.workspaces)l.manifest.devDependencies.clear(),((m=l.manifest.name)==null?void 0:m.scope)==="flocon-trpg"&&(s.delete(l.manifest.name.name)?(l.manifest.dependencies.clear(),l.manifest.peerDependencies.clear()):(se(l.manifest.dependencies,i),se(l.manifest.peerDependencies,i)));let c=await a.Cache.find(e.configuration);await e.resolveEverything({report:new a.ThrowReport,cache:c})}else throw new Error("--production=false is not supported.");r=e.storedDescriptors.values()}else throw new Error("--recursive=false is not supported.");if(s.size!==0)throw new Error("Following flocon-trpg packages are not found. Renamed or removed?: "+JSON.stringify([...s]));let f=a.miscUtils.sortMap(r,[c=>a.structUtils.stringifyIdent(c),c=>a.structUtils.isVirtualDescriptor(c)?"0":"1",c=>c.range]),w=new Set;for(let c of f.values()){let l=e.storedResolutions.get(c.descriptorHash);if(!l)continue;let d=e.storedPackages.get(l);if(!d||d.scope==="flocon-trpg"&&d.name==="servers")continue;let{descriptorHash:x}=a.structUtils.isVirtualDescriptor(c)?a.structUtils.devirtualizeDescriptor(c):c;w.has(x)||(w.add(x),o.set(c,d))}return o};function Ie(e){let t={},n=e.match(/^([^(<]+)/);if(n){let r=n[0].trim();r&&(t.name=r)}let i=e.match(/<([^>]+)>/);i&&(t.email=i[1]);let o=e.match(/\(([^)]+)\)/);return o&&(t.url=o[1]),t}var Ee=e=>{let{license:t,licenses:n,repository:i,homepage:o,author:r}=e,s=typeof r=="string"?Ie(r):r;return{license:(()=>{if(t)return A(t);if(n){if(!Array.isArray(n))return A(n);if(n.length===1)return A(n[0]);if(n.length>1)return`(${n.map(A).join(" OR ")})`}return ae})(),url:(i==null?void 0:i.url)||o,vendorName:s==null?void 0:s.name,vendorUrl:o||(s==null?void 0:s.url)}},ae="UNKNOWN",A=e=>(typeof e!="string"?e.type:e)||ae,J=(e,t,n)=>n?t:`${e}: ${t}`,ce=async(e,t,n,i)=>{let o=await oe(e,t,n,i),r=K(e.configuration.get("nodeLinker")),s=new Map;for(let w of o.values()){let m=await r.getPackagePath(e,w);if(m===null)continue;let c=g.ppath.join(m,g.Filename.manifest),l=await $(r,c);if(l===null)continue;let d=JSON.parse(l),h=(await r.fs.readdirPromise(m,{withFileTypes:!0})).filter(P=>P.isFile()).map(({name:P})=>P),D=h.find(P=>{let y=P.toLowerCase();return y==="license"||y.startsWith("license.")||y==="unlicense"||y.startsWith("unlicense.")});if(!D)continue;let v=await $(r,g.ppath.join(m,D));if(v===null)continue;let E=h.find(P=>{let y=P.toLowerCase();return y==="notice"||y.startsWith("notice.")}),b;E&&(b=await $(r,g.ppath.join(m,E)));let S=b?`${v}

NOTICE

${b}`:v,M=s.get(S);M?M.set(d.name,d):s.set(S,new Map([[d.name,d]]))}let f=`THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF FLOCON WEB SERVER PRODUCT.

`;for(let[w,m]of s.entries()){f+=`-----

`;let c=[],l=[];for(let{name:x,repository:h}of m.values())c.push(x),(h==null?void 0:h.url)&&l.push(m.size===1?h.url:`${h.url} (${x})`);let d=[];d.push(`The following software may be included in this product: ${c.join(", ")}.`),l.length>0&&d.push(`A copy of the source code may be downloaded from ${l.join(", ")}.`),d.push("This software contains the following license and notice below:"),f+=`${d.join(" ")}

`,f+=`${w.trim()}

`}return f};function*W(e){for(let t of e.split(",")){let[n,i,o]=t.trim().split("/");if(o!=null)throw new Error(`"${t}" has more than one slashes.`);let r,s;if(i==null)r=null,s=n;else{if(!n.startsWith("@"))throw new Error(`Scope must start with "@", but "${t}" does not.`);r=n.substring(1),s=i}let f=/[^0-9a-zA-Z-.]/;if(r!=null&&f.test(r))throw new Error(`"${t}" has invalid characters.`);if(s!==ie&&f.test(s))throw new Error(`"${t}" has invalid characters.`);yield{scope:r,name:s}}}var U=class extends k.Command{constructor(){super(...arguments);this.recursive=k.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=k.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.json=k.Option.Boolean("--json",!1,{description:"Format output as JSON"});this.excludeMetadata=k.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"});this.exclude=k.Option.String("--exclude",{description:'Exclude specified dependencies (e.g. --exclude="eslint,@yarnpkg/core,@types/*")'})}async execute(){let t=await I.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:i}=await I.Project.find(t,this.context.cwd);if(!i)throw new le.WorkspaceRequiredError(n.cwd,this.context.cwd);await n.restoreInstallState();let o=await re(n,this.json,this.recursive,this.production,this.exclude==null?[]:[...W(this.exclude)],this.excludeMetadata);I.treeUtils.emitTree(o,{configuration:t,stdout:this.context.stdout,json:this.json,separators:1})}};U.paths=[["licenses","list"]],U.usage=k.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"]]});var de=u(p("@yarnpkg/cli")),H=u(p("@yarnpkg/core")),N=u(p("clipanion"));var j=class extends N.Command{constructor(){super(...arguments);this.recursive=N.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=N.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.exclude=N.Option.String("--exclude",{description:'Exclude specified dependencies (e.g. --exclude="eslint,@yarnpkg/core,@types/*")'})}async execute(){let t=await H.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:i}=await H.Project.find(t,this.context.cwd);if(!i)throw new de.WorkspaceRequiredError(n.cwd,this.context.cwd);await n.restoreInstallState();let o=await ce(n,this.recursive,this.production,this.exclude==null?[]:[...W(this.exclude)]);this.context.stdout.write(o)}};j.paths=[["licenses","generate-disclaimer"]],j.usage=N.Command.Usage({description:"display the license disclaimer including all packages in the project",details:`
      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the disclaimer will exclude development dependencies.
    `,examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"],["Include licenses of production dependencies only","$0 licenses list --production"]]});var Se={commands:[U,j]},Me=Se;return Oe;})();
return plugin;
}
};
