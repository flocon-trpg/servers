/* eslint-disable */
//prettier-ignore
module.exports = {
name: "@yarnpkg/plugin-licenses",
factory: function (require) {
var plugin=(()=>{var pe=Object.create,M=Object.defineProperty;var fe=Object.getOwnPropertyDescriptor;var ue=Object.getOwnPropertyNames,V=Object.getOwnPropertySymbols,me=Object.getPrototypeOf,K=Object.prototype.hasOwnProperty,ge=Object.prototype.propertyIsEnumerable;var J=(e,t,n)=>t in e?M(e,t,{enumerable:!0,configurable:!0,writable:!0,value:n}):e[t]=n,j=(e,t)=>{for(var n in t||(t={}))K.call(t,n)&&J(e,n,t[n]);if(V)for(var n of V(t))ge.call(t,n)&&J(e,n,t[n]);return e};var he=e=>M(e,"__esModule",{value:!0});var p=e=>{if(typeof require!="undefined")return require(e);throw new Error('Dynamic require of "'+e+'" is not supported')};var A=(e,t)=>{for(var n in t)M(e,n,{get:t[n],enumerable:!0})},Pe=(e,t,n)=>{if(t&&typeof t=="object"||typeof t=="function")for(let i of ue(t))!K.call(e,i)&&i!=="default"&&M(e,i,{get:()=>t[i],enumerable:!(n=fe(t,i))||n.enumerable});return e},f=e=>Pe(he(M(e!=null?pe(me(e)):{},"default",e&&e.__esModule&&"default"in e?{get:()=>e.default,enumerable:!0}:{value:e,enumerable:!0})),e);var Ee={};A(Ee,{default:()=>Ie});var oe=f(p("@yarnpkg/cli")),L=f(p("@yarnpkg/core")),w=f(p("clipanion"));var a=f(p("@yarnpkg/core")),g=f(p("@yarnpkg/fslib"));var B={};A(B,{fs:()=>we,getPackagePath:()=>ye});var q=f(p("@yarnpkg/plugin-pnp")),W=f(p("@yarnpkg/core")),F=f(p("@yarnpkg/fslib")),Z=f(p("@yarnpkg/libzip")),ye=async(e,t)=>{ke(e);let n=W.structUtils.convertPackageToLocator(t),i={name:W.structUtils.stringifyIdent(n),reference:n.reference},o=H.getPackageInformation(i);if(!o)return null;let{packageLocation:r}=o;return r},H,ke=e=>{H||(H=module.require((0,q.getPnpPath)(e).cjs))},we=new F.VirtualFS({baseFs:new F.ZipOpenFS({libzip:(0,Z.getLibzipSync)(),readOnlyArchives:!0})});var Y={};A(Y,{_getYarnStateAliases:()=>X,fs:()=>Ne,getPackagePath:()=>xe});var b=f(p("@yarnpkg/core")),G=f(p("@yarnpkg/parsers")),v=f(p("@yarnpkg/fslib")),xe=async(e,t)=>{await ve(e);let n=b.structUtils.convertPackageToLocator(t),i=b.structUtils.stringifyLocator(n),o=D[i]||Q[i];if(!o)return null;let r=o.locations[0];return r?v.ppath.join(e.cwd,r):e.cwd},D,Q,ve=async e=>{if(!D){let t=v.ppath.join(e.configuration.projectCwd,v.Filename.nodeModules,".yarn-state.yml");D=(0,G.parseSyml)(await v.xfs.readFilePromise(t,"utf8")),Q=X(D)}},Ne=v.xfs,X=e=>Object.entries(e).reduce((t,[n,i])=>{if(!i.aliases)return t;let o=b.structUtils.parseLocator(n);for(let r of i.aliases){let s=b.structUtils.makeLocator(o,r),u=b.structUtils.stringifyLocator(s);t[u]=i}return t},{});var _=e=>{switch(e){case"pnp":return B;case"node-modules":return Y;default:throw new Error("Unsupported linker")}};var ee="*",_e=g.npath.basename(__dirname)==="@yarnpkg"?g.ppath.join(g.npath.toPortablePath(__dirname),"../.."):g.ppath.join(g.npath.toPortablePath(__dirname),".."),te=async(e,t,n,i,o,r)=>{let s={},u={children:s},x=await ie(e,n,i,o),m=_(e.configuration.get("nodeLinker"));for(let[c,l]of x.entries()){let d=await m.getPackagePath(e,l);if(d===null)continue;let P=JSON.parse(await m.fs.readFilePromise(g.ppath.join(d,g.Filename.manifest),"utf8")),{license:h,url:I,vendorName:T,vendorUrl:E}=be(P);s[h]||(s[h]={value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,h),children:{}});let S=a.structUtils.convertPackageToLocator(l),y=a.formatUtils.tuple(a.formatUtils.Type.DEPENDENT,{locator:S,descriptor:c}),k=r?{}:j(j(j({},I?{url:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,z("URL",I,t))}}:{}),T?{vendorName:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,z("VendorName",T,t))}}:{}),E?{vendorUrl:{value:a.formatUtils.tuple(a.formatUtils.Type.NO_HINT,z("VendorUrl",E,t))}}:{}),ce={value:y,children:k},le=a.structUtils.stringifyLocator(S),de=s[h].children;de[le]=ce}return u},ne=(e,t)=>{for(let n of t)[...e].filter(([,i])=>i.scope!==n.scope?!1:n.name===ee?!0:i.name===n.name).forEach(([i])=>{e.delete(i)})},ie=async(e,t,n,i)=>{var m;let o=new Map,r,s=new Set(["api-server","cache"]);if(t){if(n){for(let l of e.workspaces)l.manifest.devDependencies.clear(),((m=l.manifest.name)==null?void 0:m.scope)==="flocon-trpg"&&(s.delete(l.manifest.name.name)?(l.manifest.dependencies.clear(),l.manifest.peerDependencies.clear()):(ne(l.manifest.dependencies,i),ne(l.manifest.peerDependencies,i)));let c=await a.Cache.find(e.configuration);await e.resolveEverything({report:new a.ThrowReport,cache:c})}else throw new Error("--production=false is not supported.");r=e.storedDescriptors.values()}else throw new Error("--recursive=false is not supported.");if(s.size!==0)throw new Error("Following flocon-trpg packages are not found. Renamed or removed?: "+JSON.stringify([...s]));let u=a.miscUtils.sortMap(r,[c=>a.structUtils.stringifyIdent(c),c=>a.structUtils.isVirtualDescriptor(c)?"0":"1",c=>c.range]),x=new Set;for(let c of u.values()){let l=e.storedResolutions.get(c.descriptorHash);if(!l)continue;let d=e.storedPackages.get(l);if(!d||d.scope==="flocon-trpg"&&d.name==="servers")continue;let{descriptorHash:P}=a.structUtils.isVirtualDescriptor(c)?a.structUtils.devirtualizeDescriptor(c):c;x.has(P)||(x.add(P),o.set(c,d))}return o};function Te(e){let t={},n=e.match(/^([^(<]+)/);if(n){let r=n[0].trim();r&&(t.name=r)}let i=e.match(/<([^>]+)>/);i&&(t.email=i[1]);let o=e.match(/\(([^)]+)\)/);return o&&(t.url=o[1]),t}var be=e=>{let{license:t,licenses:n,repository:i,homepage:o,author:r}=e,s=typeof r=="string"?Te(r):r;return{license:(()=>{if(t)return C(t);if(n){if(!Array.isArray(n))return C(n);if(n.length===1)return C(n[0]);if(n.length>1)return`(${n.map(C).join(" OR ")})`}return re})(),url:(i==null?void 0:i.url)||o,vendorName:s==null?void 0:s.name,vendorUrl:o||(s==null?void 0:s.url)}},re="UNKNOWN",C=e=>(typeof e!="string"?e.type:e)||re,z=(e,t,n)=>n?t:`${e}: ${t}`,se=async(e,t,n,i)=>{let o=await ie(e,t,n,i),r=_(e.configuration.get("nodeLinker")),s=new Map;for(let x of o.values()){let m=await r.getPackagePath(e,x);if(m===null)continue;let c=JSON.parse(await r.fs.readFilePromise(g.ppath.join(m,g.Filename.manifest),"utf8")),d=(await r.fs.readdirPromise(m,{withFileTypes:!0})).filter(y=>y.isFile()).map(({name:y})=>y),P=d.find(y=>{let k=y.toLowerCase();return k==="license"||k.startsWith("license.")||k==="unlicense"||k.startsWith("unlicense.")});if(!P)continue;let h=await r.fs.readFilePromise(g.ppath.join(m,P),"utf8"),I=d.find(y=>{let k=y.toLowerCase();return k==="notice"||k.startsWith("notice.")}),T;I&&(T=await r.fs.readFilePromise(g.ppath.join(m,I),"utf8"));let E=T?`${h}

NOTICE

${T}`:h,S=s.get(E);S?S.set(c.name,c):s.set(E,new Map([[c.name,c]]))}let u=`THE FOLLOWING SETS FORTH ATTRIBUTION NOTICES FOR THIRD PARTY SOFTWARE THAT MAY BE CONTAINED IN PORTIONS OF FLOCON WEB SERVER PRODUCT.

`;for(let[x,m]of s.entries()){u+=`-----

`;let c=[],l=[];for(let{name:P,repository:h}of m.values())c.push(P),(h==null?void 0:h.url)&&l.push(m.size===1?h.url:`${h.url} (${P})`);let d=[];d.push(`The following software may be included in this product: ${c.join(", ")}.`),l.length>0&&d.push(`A copy of the source code may be downloaded from ${l.join(", ")}.`),d.push("This software contains the following license and notice below:"),u+=`${d.join(" ")}

`,u+=`${x.trim()}

`}return u};function*R(e){for(let t of e.split(",")){let[n,i,o]=t.trim().split("/");if(o!=null)throw new Error(`"${t}" has more than one slashes.`);let r,s;if(i==null)r=null,s=n;else{if(!n.startsWith("@"))throw new Error(`Scope must start with "@", but "${t}" does not.`);r=n.substring(1),s=i}let u=/[^0-9a-zA-Z-.]/;if(r!=null&&u.test(r))throw new Error(`"${t}" has invalid characters.`);if(s!==ee&&u.test(s))throw new Error(`"${t}" has invalid characters.`);yield{scope:r,name:s}}}var O=class extends w.Command{constructor(){super(...arguments);this.recursive=w.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=w.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.json=w.Option.Boolean("--json",!1,{description:"Format output as JSON"});this.excludeMetadata=w.Option.Boolean("--exclude-metadata",!1,{description:"Exclude dependency metadata from output"});this.exclude=w.Option.String("--exclude",{description:'Exclude specified dependencies (e.g. --exclude="eslint,@yarnpkg/core,@types/*")'})}async execute(){let t=await L.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:i}=await L.Project.find(t,this.context.cwd);if(!i)throw new oe.WorkspaceRequiredError(n.cwd,this.context.cwd);await n.restoreInstallState();let o=await te(n,this.json,this.recursive,this.production,this.exclude==null?[]:[...R(this.exclude)],this.excludeMetadata);L.treeUtils.emitTree(o,{configuration:t,stdout:this.context.stdout,json:this.json,separators:1})}};O.paths=[["licenses","list"]],O.usage=w.Command.Usage({description:"display the licenses for all packages in the project",details:`
      This command prints the license information for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the listing will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the listing will exclude development dependencies.
    `,examples:[["List all licenses of direct dependencies","$0 licenses list"],["List all licenses of direct and transitive dependencies","$0 licenses list --recursive"],["List all licenses of production dependencies only","$0 licenses list --production"]]});var ae=f(p("@yarnpkg/cli")),$=f(p("@yarnpkg/core")),N=f(p("clipanion"));var U=class extends N.Command{constructor(){super(...arguments);this.recursive=N.Option.Boolean("-R,--recursive",!1,{description:"Include transitive dependencies (dependencies of direct dependencies)"});this.production=N.Option.Boolean("--production",!1,{description:"Exclude development dependencies"});this.exclude=N.Option.String("--exclude",{description:'Exclude specified dependencies (e.g. --exclude="eslint,@yarnpkg/core,@types/*")'})}async execute(){let t=await $.Configuration.find(this.context.cwd,this.context.plugins),{project:n,workspace:i}=await $.Project.find(t,this.context.cwd);if(!i)throw new ae.WorkspaceRequiredError(n.cwd,this.context.cwd);await n.restoreInstallState();let o=await se(n,this.recursive,this.production,this.exclude==null?[]:[...R(this.exclude)]);this.context.stdout.write(o)}};U.paths=[["licenses","generate-disclaimer"]],U.usage=N.Command.Usage({description:"display the license disclaimer including all packages in the project",details:`
      This command prints the license disclaimer for packages in the project. By default, only direct dependencies are listed.

      If \`-R,--recursive\` is set, the disclaimer will include transitive dependencies (dependencies of direct dependencies).

      If \`--production\` is set, the disclaimer will exclude development dependencies.
    `,examples:[["Include licenses of direct dependencies","$0 licenses generate-disclaimer"],["Include licenses of direct and transitive dependencies","$0 licenses generate-disclaimer --recursive"],["Include licenses of production dependencies only","$0 licenses list --production"]]});var Le={commands:[O,U]},Ie=Le;return Ee;})();
return plugin;
}
};
