# Operational Transformation library

io-tsでは、Recordのkeyをstringにすることはできるが、例えば ('1' | '2' | '3') にすることはシンプルな方法で実現できない模様。そのため、代わりにstringを使っている。

権限の処理(例えばisPrivate === true の値は作成者以外の編集を拒否するなど)は、全てserverTransformで行う。

一部の人には閲覧できない値を除外する作業は、全てtoClientStateで行う。

クライアントにStateを渡すのは文字通りtoClientStateで行う。クライアントにOperationを渡すには、toClientState(prevState)とtoClientState(nextState)を求めてからdiffする。かつてはtoClientOperationを定義しておりそれを用いていたが、activeBoardKeyが後で追加され、activeBoardKey変わったときにそれに伴うPieceの変更も含めなければならず、さらにPieceを子に持つCharacter、DicePieceValueにも変更を反映させなければならず… ということをしなければならなくなり、toClientOperationを使うのはパフォーマンスこそいいもののロジックが複雑化して大変なのでdiffを取る作戦を採用することにした。ただ、パフォーマンスのためにactiveBoardKeyが絡まない部分だけtoClientOperationを用い、残りはdiffを用いるという折衷案もありかもしれない。

ParticipantのRoleなどは、クライアント側によるoperationでは変更できず、サーバーによるoperationでしか変更できない仕様にしている。そのため、クライアント側でRoleを変更するOperationを作成するべきではない(もしそのようなOperationをサーバーに送信しても無視される)。ただし、サーバーから受け取ったOperationにRoleの変更が含まれていて、そのOperationをクライアントのStateにapplyしたり、clientTransformする機会はある。

io-ts のインスタンスにおける T | null | undefined (a.k.a. Maybe&lt;T&gt;)で、nullとundefinedは通常は常に同じ意味。理由は、io-tsにおけるnullとundefinedの挙動をよく知らないため、とりあえずMaybe&lt;T&gt;にしておけば確実かなと思ったから。あまり良くない。

board,characterなどのfirst keyはuserUid(participantのfirst key)と等しい。これらをparticipantの子として持たせていない理由は、UndoやRedo処理をparticipantの削除などなしで行いやすくするため。

composeDownOperationは、例えば { oldValue: 1, newValue: undefined }, { oldValue:undefined, newValue: 2 } をcomposeしたときにこれはupdateになるべきだが実際は{oldValue:undefined}のreplaceとなるという仕様がある。このままでは不具合が起こるが、restoreでTwoWayOperationに変換する工程でupdateになるため、最終的に正常な状態になる。

composeUpOperation（ともしかしたらapply,applyBack）にも同様の仕様があるが、これらは昔は意味があったがおそらく今はない。composeUpOperationは現状では存在意義がないので削除した。

現状の仕様だと、API側のOTは、「composeDownOperationでまとめる→restoreで正常なtwoWayOperationにする」という流れになっている。だが、これは「逐次restoreしていく→composeTwoWayOperationでまとめる」にするほうが綺麗。パフォーマンスに関してはrestoreの回数が増えるのでstateを更新する回数も増えるため、この点でパフォーマンスが悪くなる可能性があるが、operationが肥大でない限り、diffと比べればそこまで重くないと思われる。あわせてcomposeDownOperationは廃止できる。ただし、書き換えが面倒なのと、newValueの設定をしなくていいというメリットはあるのと、restoreによる正常化という特殊な工程はすべてrecordOperation系に任せているので、とりあえず現状維持の方針。
